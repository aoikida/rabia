/*
   Copyright 2024 Aoi Kida

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*
    Copyright 2021 Rabia Research Team and Developers

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.proto

package message

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClientRequest:
// from proxy to network, among networks
//
// Proposal, State, Vote, ProposalRequest, ProposalReply, and Decision:
// from consensus to network, among networks, from network to consensus
//
// ProposalRequest:
// Phase: SvrId (the source server's id), Value: the sequence number of the proposal
// from Executor to the local network layer then to another network layer (based on message.Value?)
//
// ProposalReply:
// Phase: the destination server's id, Value: the sequence number of the proposal
// from MsgHandler to the local network layer then to another network layer (based on message.Phase)
type MsgType int32

const (
	ClientRequest   MsgType = 0
	Proposal        MsgType = 1
	State           MsgType = 2
	Vote            MsgType = 3
	ProposalRequest MsgType = 4
	ProposalReply   MsgType = 5
	Decision        MsgType = 6
	PQcheck         MsgType = 7
)

var MsgType_name = map[int32]string{
	0: "ClientRequest",
	1: "Proposal",
	2: "State",
	3: "Vote",
	4: "ProposalRequest",
	5: "ProposalReply",
	6: "Decision",
	7: "PQcheck",
}

var MsgType_value = map[string]int32{
	"ClientRequest":   0,
	"Proposal":        1,
	"State":           2,
	"Vote":            3,
	"ProposalRequest": 4,
	"ProposalReply":   5,
	"Decision":        6,
	"PQcheck":         7,
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}

// Command is used from client to proxy and from proxy to client only. When a client sends a Command message to a proxy,
// the message carries one or more client requests/commands/proposals to be appended to the replicated log. The SvrSeq
// field is not used. When a proxy sends a Command message to a connected client, the message carries the agreed proposal
// and the slot number in the SvrSeq field.
//
// If the client batch size = 1, a valid Command object looks like:
// Command{CliId: 0, CliSeq: 1000, SvrSeq: 0, Commands: ["0key1val1"]}
//
// If the client batch size = 3, a valid Command object looks like:
// Command{CliId: 0, CliSeq: 1001, SvrSeq: 0, Commands: ["0key1val1", "0key2val2", "1key3"]}
//
// CliId:  the from/to client id
// CliSeq: the client sequence
// SvrSeq: the decided slot # (from proxy to client only)
// Commands:
// each command in the array looks is of the form <operation type><key>[<value>], e.g., 0key1val1 and 1key2 are
// both valid. Regarding the operation type, 0 stands for a write operation and 1 stands for a read operation.
//
// Each command is a string of 17 bytes (modifiable through Conf.KeyLen and Conf.ValLen)
// [0:1]   (1 byte): "0" == a write operation,  "1" == a read operation
// [1:9]  (8 bytes): a string Key
// [9:17] (8 bytes): a string Value
type Command struct {
	CliId    uint32   `protobuf:"varint,1,opt,name=CliId,proto3" json:"CliId,omitempty"`
	CliSeq   uint32   `protobuf:"varint,2,opt,name=CliSeq,proto3" json:"CliSeq,omitempty"`
	SvrSeq   uint32   `protobuf:"varint,3,opt,name=SvrSeq,proto3" json:"SvrSeq,omitempty"`
	Commands []string `protobuf:"bytes,4,rep,name=Commands,proto3" json:"Commands,omitempty"`
}

func (m *Command) Reset()      { *m = Command{} }
func (*Command) ProtoMessage() {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}
func (m *Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return m.Size()
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

// To pass around a ConsensusObj among layers, embed it as a field of a Msg object because then we only need to keep Msg
// channels for inter-layer communications.
//
// If the client batch size = 1 and the proxy batch size = 1, valid ConsensusObj objects look like:
// ConsensusObj {ProId: 4, ProSeq: 500, SvrSeq: 714, IsNull: true}
// ConsensusObj {ProId: 4, ProSeq: 500, SvrSeq: 714, IsNull: false, CliIds: [0], CliSeqs: [1000],
// Commands: ["0key1val1"]}
//
// If the client batch size = 2 and the proxy batch size = 5, valid ConsensusObj object looks like:
// ConsensusObj {ProId: 4, ProSeq: 500, SvrSeq: 714, IsNull: false, CliIds: [0, 0, 0, 0, 0],
// CliSeqs: [1000, 1001, 1002, 1003, 1004], Commands: ["0k1v1", "1k2", "0k3v3",
// "1k4", "0k5v5", "1k6", "0k7v7", "1k8", "0k9v9", "1k10"]}
//
// ConsensusObj {ProId: 4, ProSeq: 500, SvrSeq: 119, IsNull: false, CliIds: [0, 0, 0, 1, 1],
// CliSeqs: [1000, 1001, 1002, 999, 1000], Commands: ["0k1v1", "1k2", "0k3v3",
// "1k4", "0k5v5", "1k6", "0k1v1", "1k2", "0k3v3", "1k4"]}
//
// ProId:    the id of the proxy that initiates this object
// ProSeq:   the sequence of this object
// SvrSeq:   the decision slot number (0 could mean unassigned / decision in process)
// IsNull:   true if this slot is a NULL slot. if false, the following fields are used, see valid formats above
// CliIds:   the client id's that are associated with commands
// CliSeqs:  the client sequences that are associated with commands
// Commands: the clients' commands
type ConsensusObj struct {
	ProId    uint32   `protobuf:"varint,1,opt,name=ProId,proto3" json:"ProId,omitempty"`
	ProSeq   uint32   `protobuf:"varint,2,opt,name=ProSeq,proto3" json:"ProSeq,omitempty"`
	SvrSeq   uint32   `protobuf:"varint,3,opt,name=SvrSeq,proto3" json:"SvrSeq,omitempty"`
	IsNull   bool     `protobuf:"varint,4,opt,name=IsNull,proto3" json:"IsNull,omitempty"`
	CliIds   []uint32 `protobuf:"varint,5,rep,packed,name=CliIds,proto3" json:"CliIds,omitempty"`
	CliSeqs  []uint32 `protobuf:"varint,6,rep,packed,name=CliSeqs,proto3" json:"CliSeqs,omitempty"`
	Commands []string `protobuf:"bytes,7,rep,name=Commands,proto3" json:"Commands,omitempty"`
}

func (m *ConsensusObj) Reset()      { *m = ConsensusObj{} }
func (*ConsensusObj) ProtoMessage() {}
func (*ConsensusObj) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}
func (m *ConsensusObj) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusObj) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusObj.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusObj) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusObj.Merge(m, src)
}
func (m *ConsensusObj) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusObj) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusObj.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusObj proto.InternalMessageInfo

// A Msg object can be passed around without a embedded ConsensusObj -- simply let that field be null
//
// Type: one of the message types listed above
// Phase:  the phase of the message
// Value: reserved for special occasions, see below
// Obj: a pointer to a consensus object, could be null for binary consensus messages and other cases
//
// The usages of the Value field:
// State, and Vote messages: my binary consensus message of phase P round R
// ProposalRequest and ProposalReply: the sequence number of the proposal
// for internal communications between executor and messageHandler, see binConMsgHandling()
type Msg struct {
	Type  MsgType       `protobuf:"varint,1,opt,name=Type,proto3,enum=message.MsgType" json:"Type,omitempty"`
	Phase uint32        `protobuf:"varint,2,opt,name=Phase,proto3" json:"Phase,omitempty"`
	Value uint32        `protobuf:"varint,3,opt,name=Value,proto3" json:"Value,omitempty"`
	Obj   *ConsensusObj `protobuf:"bytes,4,opt,name=Obj,proto3" json:"Obj,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{2}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("message.MsgType", MsgType_name, MsgType_value)
	proto.RegisterType((*Command)(nil), "message.Command")
	proto.RegisterType((*ConsensusObj)(nil), "message.ConsensusObj")
	proto.RegisterType((*Msg)(nil), "message.Msg")
}

func init() { proto.RegisterFile("message.proto", fileDescriptor_33c57e4bae7b9afd) }

var fileDescriptor_33c57e4bae7b9afd = []byte{
	// 464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x31, 0x6f, 0xd3, 0x40,
	0x18, 0x86, 0x7d, 0xb5, 0x63, 0xa7, 0x5f, 0x5b, 0x30, 0x07, 0x54, 0x56, 0x87, 0x4f, 0x51, 0x85,
	0x44, 0x84, 0x44, 0x2a, 0x95, 0x7f, 0x80, 0xbb, 0x64, 0x28, 0x0d, 0x0e, 0xea, 0x6e, 0x27, 0x87,
	0xe3, 0xd6, 0xf1, 0xa5, 0x3e, 0x1b, 0xa9, 0x5b, 0xc5, 0x2f, 0xe0, 0x67, 0xf0, 0x13, 0x10, 0x13,
	0x63, 0xc7, 0x8c, 0x1d, 0xf1, 0x65, 0x61, 0xec, 0xc8, 0x88, 0xee, 0x7c, 0x69, 0x0b, 0x12, 0x9b,
	0x9f, 0xf7, 0xbb, 0x7b, 0xdf, 0xf7, 0xb3, 0x0d, 0x3b, 0x73, 0x26, 0x44, 0x9c, 0xb2, 0xc1, 0xa2,
	0xe4, 0x15, 0xa7, 0x9e, 0xc1, 0xbd, 0xd7, 0x69, 0x56, 0xcd, 0xea, 0x64, 0x30, 0xe1, 0xf3, 0x83,
	0x94, 0xa7, 0xfc, 0x40, 0xcf, 0x93, 0xfa, 0xa3, 0x26, 0x0d, 0xfa, 0xa9, 0xbd, 0xb7, 0x7f, 0x0e,
	0x5e, 0xc8, 0xe7, 0xf3, 0xb8, 0x98, 0xd2, 0x67, 0xd0, 0x09, 0xf3, 0x6c, 0x38, 0x0d, 0x48, 0x8f,
	0xf4, 0x77, 0xa2, 0x16, 0xe8, 0x2e, 0xb8, 0x61, 0x9e, 0x8d, 0xd9, 0x45, 0xb0, 0xa1, 0x65, 0x43,
	0x4a, 0x1f, 0x7f, 0x2a, 0x95, 0x6e, 0xb7, 0x7a, 0x4b, 0x74, 0x0f, 0xba, 0xc6, 0x50, 0x04, 0x4e,
	0xcf, 0xee, 0x6f, 0x46, 0x77, 0xbc, 0xff, 0x9d, 0xc0, 0x76, 0xc8, 0x0b, 0xc1, 0x0a, 0x51, 0x8b,
	0x93, 0xe4, 0x4c, 0x45, 0x8e, 0x4a, 0x7e, 0x1f, 0xa9, 0x41, 0x59, 0x8f, 0x4a, 0xfe, 0x20, 0xb2,
	0xa5, 0xff, 0x46, 0xee, 0x82, 0x3b, 0x14, 0xef, 0xea, 0x3c, 0x0f, 0x9c, 0x1e, 0xe9, 0x77, 0x23,
	0x43, 0xa6, 0xfa, 0x70, 0x2a, 0x82, 0x4e, 0xcf, 0x36, 0xd5, 0x87, 0x53, 0x41, 0x03, 0xf0, 0xda,
	0x25, 0x44, 0xe0, 0xea, 0xc1, 0x1a, 0xff, 0x2a, 0xef, 0xfd, 0x53, 0xfe, 0x8a, 0x80, 0x7d, 0x2c,
	0x52, 0xfa, 0x02, 0x9c, 0x0f, 0x97, 0x0b, 0xa6, 0x2b, 0x3f, 0x3a, 0xf4, 0x07, 0xeb, 0xef, 0x70,
	0x2c, 0x52, 0xa5, 0x47, 0x7a, 0xaa, 0x37, 0x9b, 0xc5, 0x82, 0x99, 0x15, 0x5a, 0x50, 0xea, 0x69,
	0x9c, 0xd7, 0xcc, 0x2c, 0xd0, 0x02, 0x7d, 0x09, 0xf6, 0x49, 0x72, 0xa6, 0xcb, 0x6f, 0x1d, 0x3e,
	0xbf, 0x33, 0x7c, 0xf8, 0xa6, 0x22, 0x75, 0xe2, 0xd5, 0x67, 0x02, 0x9e, 0x89, 0xa1, 0x4f, 0x60,
	0x27, 0xcc, 0x33, 0x56, 0x54, 0x11, 0xbb, 0xa8, 0x99, 0xa8, 0x7c, 0x8b, 0x6e, 0x43, 0x77, 0x54,
	0xf2, 0x05, 0x17, 0x71, 0xee, 0x13, 0xba, 0x09, 0x9d, 0x71, 0x15, 0x57, 0xcc, 0xdf, 0xa0, 0x5d,
	0x70, 0x4e, 0x79, 0xc5, 0x7c, 0x9b, 0x3e, 0x85, 0xc7, 0xeb, 0x23, 0xeb, 0x7b, 0x8e, 0xb2, 0xba,
	0x17, 0x17, 0xf9, 0xa5, 0xdf, 0x51, 0x56, 0x47, 0x6c, 0x92, 0x89, 0x8c, 0x17, 0xbe, 0x4b, 0xb7,
	0xc0, 0x1b, 0xbd, 0x9f, 0xcc, 0xd8, 0xe4, 0xdc, 0xf7, 0xde, 0x1e, 0x5d, 0x37, 0x68, 0x2d, 0x1b,
	0xb4, 0x6e, 0x1a, 0xb4, 0x6e, 0x1b, 0x24, 0xbf, 0x1b, 0x24, 0x57, 0x12, 0xc9, 0x57, 0x89, 0xe4,
	0x9b, 0x44, 0xf2, 0x43, 0x22, 0xb9, 0x96, 0x48, 0x96, 0x12, 0xc9, 0x4f, 0x89, 0xe4, 0x97, 0x44,
	0xeb, 0x56, 0x22, 0xf9, 0xb2, 0x42, 0x6b, 0xb9, 0x42, 0xeb, 0x66, 0x85, 0x56, 0xe2, 0xea, 0xdf,
	0xef, 0xcd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xae, 0x60, 0xdf, 0xc7, 0x02, 0x00, 0x00,
}

func (x MsgType) String() string {
	s, ok := MsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Command) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Command)
	if !ok {
		that2, ok := that.(Command)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CliId != that1.CliId {
		return false
	}
	if this.CliSeq != that1.CliSeq {
		return false
	}
	if this.SvrSeq != that1.SvrSeq {
		return false
	}
	if len(this.Commands) != len(that1.Commands) {
		return false
	}
	for i := range this.Commands {
		if this.Commands[i] != that1.Commands[i] {
			return false
		}
	}
	return true
}
func (this *ConsensusObj) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsensusObj)
	if !ok {
		that2, ok := that.(ConsensusObj)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProId != that1.ProId {
		return false
	}
	if this.ProSeq != that1.ProSeq {
		return false
	}
	if this.SvrSeq != that1.SvrSeq {
		return false
	}
	if this.IsNull != that1.IsNull {
		return false
	}
	if len(this.CliIds) != len(that1.CliIds) {
		return false
	}
	for i := range this.CliIds {
		if this.CliIds[i] != that1.CliIds[i] {
			return false
		}
	}
	if len(this.CliSeqs) != len(that1.CliSeqs) {
		return false
	}
	for i := range this.CliSeqs {
		if this.CliSeqs[i] != that1.CliSeqs[i] {
			return false
		}
	}
	if len(this.Commands) != len(that1.Commands) {
		return false
	}
	for i := range this.Commands {
		if this.Commands[i] != that1.Commands[i] {
			return false
		}
	}
	return true
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.Obj.Equal(that1.Obj) {
		return false
	}
	return true
}
func (this *Command) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&message.Command{")
	s = append(s, "CliId: "+fmt.Sprintf("%#v", this.CliId)+",\n")
	s = append(s, "CliSeq: "+fmt.Sprintf("%#v", this.CliSeq)+",\n")
	s = append(s, "SvrSeq: "+fmt.Sprintf("%#v", this.SvrSeq)+",\n")
	s = append(s, "Commands: "+fmt.Sprintf("%#v", this.Commands)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsensusObj) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&message.ConsensusObj{")
	s = append(s, "ProId: "+fmt.Sprintf("%#v", this.ProId)+",\n")
	s = append(s, "ProSeq: "+fmt.Sprintf("%#v", this.ProSeq)+",\n")
	s = append(s, "SvrSeq: "+fmt.Sprintf("%#v", this.SvrSeq)+",\n")
	s = append(s, "IsNull: "+fmt.Sprintf("%#v", this.IsNull)+",\n")
	s = append(s, "CliIds: "+fmt.Sprintf("%#v", this.CliIds)+",\n")
	s = append(s, "CliSeqs: "+fmt.Sprintf("%#v", this.CliSeqs)+",\n")
	s = append(s, "Commands: "+fmt.Sprintf("%#v", this.Commands)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&message.Msg{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Obj != nil {
		s = append(s, "Obj: "+fmt.Sprintf("%#v", this.Obj)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Command) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commands[iNdEx])
			copy(dAtA[i:], m.Commands[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Commands[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SvrSeq != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SvrSeq))
		i--
		dAtA[i] = 0x18
	}
	if m.CliSeq != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.CliSeq))
		i--
		dAtA[i] = 0x10
	}
	if m.CliId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.CliId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusObj) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusObj) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commands[iNdEx])
			copy(dAtA[i:], m.Commands[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Commands[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CliSeqs) > 0 {
		dAtA2 := make([]byte, len(m.CliSeqs)*10)
		var j1 int
		for _, num := range m.CliSeqs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMessage(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CliIds) > 0 {
		dAtA4 := make([]byte, len(m.CliIds)*10)
		var j3 int
		for _, num := range m.CliIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMessage(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsNull {
		i--
		if m.IsNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SvrSeq != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SvrSeq))
		i--
		dAtA[i] = 0x18
	}
	if m.ProSeq != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ProSeq))
		i--
		dAtA[i] = 0x10
	}
	if m.ProId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ProId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		{
			size, err := m.Obj.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Value != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.Phase != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedCommand(r randyMessage, easy bool) *Command {
	this := &Command{}
	this.CliId = uint32(r.Uint32())
	this.CliSeq = uint32(r.Uint32())
	this.SvrSeq = uint32(r.Uint32())
	v1 := r.Intn(10)
	this.Commands = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.Commands[i] = string(randStringMessage(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedConsensusObj(r randyMessage, easy bool) *ConsensusObj {
	this := &ConsensusObj{}
	this.ProId = uint32(r.Uint32())
	this.ProSeq = uint32(r.Uint32())
	this.SvrSeq = uint32(r.Uint32())
	this.IsNull = bool(bool(r.Intn(2) == 0))
	v2 := r.Intn(10)
	this.CliIds = make([]uint32, v2)
	for i := 0; i < v2; i++ {
		this.CliIds[i] = uint32(r.Uint32())
	}
	v3 := r.Intn(10)
	this.CliSeqs = make([]uint32, v3)
	for i := 0; i < v3; i++ {
		this.CliSeqs[i] = uint32(r.Uint32())
	}
	v4 := r.Intn(10)
	this.Commands = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.Commands[i] = string(randStringMessage(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMsg(r randyMessage, easy bool) *Msg {
	this := &Msg{}
	this.Type = MsgType([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	this.Phase = uint32(r.Uint32())
	this.Value = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.Obj = NewPopulatedConsensusObj(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyMessage interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMessage(r randyMessage) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMessage(r randyMessage) string {
	v5 := r.Intn(100)
	tmps := make([]rune, v5)
	for i := 0; i < v5; i++ {
		tmps[i] = randUTF8RuneMessage(r)
	}
	return string(tmps)
}
func randUnrecognizedMessage(r randyMessage, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMessage(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMessage(dAtA []byte, r randyMessage, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(key))
		v6 := r.Int63()
		if r.Intn(2) == 0 {
			v6 *= -1
		}
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(v6))
	case 1:
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMessage(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMessage(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CliId != 0 {
		n += 1 + sovMessage(uint64(m.CliId))
	}
	if m.CliSeq != 0 {
		n += 1 + sovMessage(uint64(m.CliSeq))
	}
	if m.SvrSeq != 0 {
		n += 1 + sovMessage(uint64(m.SvrSeq))
	}
	if len(m.Commands) > 0 {
		for _, s := range m.Commands {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *ConsensusObj) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProId != 0 {
		n += 1 + sovMessage(uint64(m.ProId))
	}
	if m.ProSeq != 0 {
		n += 1 + sovMessage(uint64(m.ProSeq))
	}
	if m.SvrSeq != 0 {
		n += 1 + sovMessage(uint64(m.SvrSeq))
	}
	if m.IsNull {
		n += 2
	}
	if len(m.CliIds) > 0 {
		l = 0
		for _, e := range m.CliIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.CliSeqs) > 0 {
		l = 0
		for _, e := range m.CliSeqs {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.Commands) > 0 {
		for _, s := range m.Commands {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.Phase != 0 {
		n += 1 + sovMessage(uint64(m.Phase))
	}
	if m.Value != 0 {
		n += 1 + sovMessage(uint64(m.Value))
	}
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Command) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Command{`,
		`CliId:` + fmt.Sprintf("%v", this.CliId) + `,`,
		`CliSeq:` + fmt.Sprintf("%v", this.CliSeq) + `,`,
		`SvrSeq:` + fmt.Sprintf("%v", this.SvrSeq) + `,`,
		`Commands:` + fmt.Sprintf("%v", this.Commands) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsensusObj) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsensusObj{`,
		`ProId:` + fmt.Sprintf("%v", this.ProId) + `,`,
		`ProSeq:` + fmt.Sprintf("%v", this.ProSeq) + `,`,
		`SvrSeq:` + fmt.Sprintf("%v", this.SvrSeq) + `,`,
		`IsNull:` + fmt.Sprintf("%v", this.IsNull) + `,`,
		`CliIds:` + fmt.Sprintf("%v", this.CliIds) + `,`,
		`CliSeqs:` + fmt.Sprintf("%v", this.CliSeqs) + `,`,
		`Commands:` + fmt.Sprintf("%v", this.Commands) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Obj:` + strings.Replace(this.Obj.String(), "ConsensusObj", "ConsensusObj", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CliId", wireType)
			}
			m.CliId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CliId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CliSeq", wireType)
			}
			m.CliSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CliSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrSeq", wireType)
			}
			m.SvrSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProId", wireType)
			}
			m.ProId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProSeq", wireType)
			}
			m.ProSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrSeq", wireType)
			}
			m.SvrSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNull = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CliIds = append(m.CliIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CliIds) == 0 {
					m.CliIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CliIds = append(m.CliIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CliIds", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CliSeqs = append(m.CliSeqs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CliSeqs) == 0 {
					m.CliSeqs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CliSeqs = append(m.CliSeqs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CliSeqs", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &ConsensusObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
